IO调度器的总体目标是希望让磁头能够总是往一个方向移动,移动到底了再往 反方向走,这恰恰就是现实生活中的电梯模型,所以IO调度器也被叫做电梯. (elevator)而 相应的算法也就被叫做电梯算法.而Linux中IO调度的电梯算法有好几种,一个叫做 as(Anticipatory),一个叫做 cfq(Complete Fairness Queueing),一个叫做deadline,还 有一个叫做noop( No Operation).具体使用哪种算法我们可以在启动的时候通过内核参数 elevator来指定.


## I/O调度的4种算法

### 1、CFQ(完全公平排队I/O调度程序)
#### 特点
- 在最新的内核版本和发行版中,都选择CFQ做为默认的I/O调度器,对于通用的服 务器也是最好的选择.

- CFQ试图均匀地分布对I/O带宽的访问,避免进程被饿死并实现较低的延迟,是 deadline和as调度器的折中.

- CFQ对于多媒体应用(video,audio)和桌面系统是最好的选择.

- CFQ赋予I/O请求一个优先级,而I/O优先级请求独立于进程优先级,高优先级的 进程的读写不能自动地继承高的I/O优先级.

#### 工作原理
- CFQ为每个进程/线程,单独创建一个队列来管理该进程所产生的请求,也就是说 每个进程一个队列,各队列之间的调度使用时间片来调度, 以此来保证每个进程都能被很好的分配到I/O带宽.I/O调度器每次执行一个进程的4次请求.

<br/>
### 2、NOOP(电梯式调度程序)
#### 特点
- 在Linux2.4或更早的版本的调度程序,那时只有这一种I/O调度算法.
- NOOP实现了一个简单的FIFO队列,它像电梯的工作主法一样对I/O请求进行组 织,当有一个新的请求到来时,它将请求合并到最近的请求之后,以此来保证请求同一介质.
- NOOP倾向饿死读而利于写.
- NOOP对于闪存设备,RAM,嵌入式系统是最好的选择.

#### 电梯算法饿死读请求的解释:
- 因为写请求比读请求更容易.
- 写请求通过文件系统cache,不需要等一次写完成,就可以开始下一次写操作,写 请求通过合并,堆积到I/O队列中.
- 读请求需要等到它前面所有的读操作完成,才能进行下一次读操作.在读操作之 间有几毫秒时间,而写请求在这之间就到来,饿死了后面的读请求.

<br/>
### 3、Deadline(截止时间调度程序)
#### 特点
- 通过时间以及硬盘区域进行分类,这个分类和合并要求类似于noop的调度程序.
- Deadline确保了在一个截止时间内服务请求,这个截止时间是可调整的,而默认 读期限短于写期限.这样就防止了写操作因为不能被读取而饿死的现象.
- **Deadline对数据库环境(ORACLE RAC,MYSQL等)是最好的选择.**

<br/>
### 4、AS(预料I/O调度程序)
#### 特点
- 本质上与Deadline一样,但在最后一次读操作后,要等待6ms,才能继续进行对其 它I/O请求进行调度.
- 可以从应用程序中预订一个新的读请求,改进读操作的执行,但以一些写操作为
代价.
- 它会在每个6ms中插入新的I/O操作,而会将一些小写入流合并成一个大写入流, 用写入延时换取最大的写入吞吐量.
- **AS适合于写入较多的环境,比如文件服务器 AS对数据库环境表现很差.**